在 Actor 模型中，每个 Actor 封装了自己的私有状态和行为

它们无法直接访问其它 Actor 内部状态, 只能通过异步消息进行通信

这意味着发送消息后，Actor 不需要等待这条消息被其他的 Actor 处理，

它可以继续执行其他业务逻辑，直到收到相应的回复

在 Actor 处理收到的消息时，它可以:

回复这条消息，向其它 Actor 发送消息

创建新的 Actor

以及改变其内部状态

使用 Actor 模型可以简化合约间的异步通信，

在传统 Actor 模型的基础上，Gear Protocol 额外保证了异步消息的顺序

让合约能按照消息被发送的顺序对消息进行处理，产生具有确定性的执行结果

---

Vara 的 Actor 可以是用户帐户，或者从 WASM 代码启动的合约实例

或者系统内置的预编译合约，内置合约是在 Vara runtime 中实现的，

可以给其他合约提供一些特殊的加密学算法，比如 BLS 签名，

调用原生代码执行链下计算, 比如获取随机数

以及提供访问 substrate runtime 模块的能力，比如 Staking，链上治理模块

每个 Actor 都有各自的地址，

用户与合约之间可以彼此发送消息

用户可以在 Mailbox 中读取收到的消息，然后进行回复

---

这里是一个合约的结构

其中 State 是合约的内部状态，用来保存和业务逻辑相关的状态

这些状态是持久化存储在链上的，只有合约本身能直接访问这些状态

想要查询或修改这些状态必须通过消息触发对应的入口函数

Metadata 中定义了这些入口函数输入以及输出消息的类型信息

部署合约时并不会把 Metadata 提交到链上，合约代码中只会编码他的哈希值

可以通过这个哈希值来检查 Metadata 是否和某个合约匹配

并且合约部署时会调用一次 init 函数，对内部状态进行初始化

如果初始化过程中 Gas 费不足会导致合约进入 Terminated 终止状态

正常情况下合约初始化后会进入 Active 状态

只有这个时候才能正常向合约发送消息

state 函数主要用于在链下查询合约状态，它是不需要 Gas 费的

handle 以及 handle_reply 定义了合约的主要业务逻辑

在 handle 中可以向其他地址发送消息，处理收到的消息，或者发送回复

handle_reply 专门用来处理 handle 中给其他地址发送消息后收到的回复

一条消息最多只能被回复一次，所以 handle_reply 只能向外发送消息，但是无法直接对消息进行回复

我们可以使用这两个函数实现异步的消息处理

---

Vara 上的原生代币就叫做 VARA，精确到小数点后 12 位

执行链上交易需要消耗 Gas, 可以使用 VARA 支付交易的 Gas 费

Substrate 使用 Weight 的概念来衡量链上计算的复杂度，

1 单位的 Weight 相当于标准硬件上 1 皮秒的执行时间

而 Vara 上的交易费使用 Gas 作为单位，它和 Weight 直接挂钩

1 单位的 Gas 相当于 = 1 单位的 Weight

而 1 单位的 VARA 相当于 10^12 Gas

Vara 的出块间隔为 3 秒，每个区块消耗的 Gas 上限是 七千五百亿，

相当于标准硬件上 750 毫秒的执行时间，折合成原生代币是 0.75 VARA


- 合约可预留 Gas 用于在未来执行某些任务
- 用户可使用 Gas Voucher / Gas 代金券 / 免 Gas 券 支付跟特定合约交互时所需的 Gas 费

---

Vara 上的 一切行为都可以通过消息来表示

比如

- 转账
- 合约部署
- 合约调用

每条消息都有独一无二的 id

消息中的 source 和 destination 分别代表发送方和接收方的地址

可以是用户或者合约地址

gas_limit 用于指定这条消息被处理时消耗 Gas 的上限，超出这个上限交易会终止

value 代表消息附带的金额，可以用来转账或者延长消息在用户 Mailbox 中保存的时间

消息可以携带任意的内容，通常这些内容使用 Scale Encoding 的方式来编码

---

用户通过一笔交易发送消息后，消息会进入一个全局的消息队列，

这个队列相当于一个链上的交易池

验证人节点处理交易时会按照先入先出的顺序将消息派发给对应的 Actor 处理，

同时处理过程中产生的消息又会被添加到消息队列的末尾

这个消息循环会一直执行，直到队列中没有消息，或者累计消耗的 gas 达到当前区块的上限

---

下面这张图描述是并行处理消息的逻辑，

首先并不是任意消息都会被并行处理，

由于 Gear Protocol 需要保持合约处理消息的顺序和消息发送的顺序一致

只有发往不同地址的才有可能被并行处理

根据节点的 cpu 核心数量，可以将队列中的消息归入独立的 stream，

每个 stream 会分配到不同的核心上并行处理

通过这种方式，Vara 可以最大程度的利用多核 cpu 的资源提高网络的吞吐量